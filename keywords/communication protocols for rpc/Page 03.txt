百度首页登录 加入VIP 意见反馈下载客户端网页 新闻 贴吧 知道 视频 音乐 图片 地图 文库 |
百度文库_文档分享平台
2 悬赏文档
全部DOCPPTTXTPDFXLS
首页分类精品内容 申请认证 机构合作 频道专区 百度智慧课堂  百度教育VIP   个人中心
百度文库专业资料
communication protocols for Remote Procedure Call (RPC). These protocols include Request (R
共享文档
IJCSNS International Journal of Computer Science and Network Security, VOL.7 No.7, July 2007    63 Manuscript received 
 July 5, 2007  Manuscript revised  July 25, 2007  Modeling and Formal Verification of Communication Protocols  for Remote Procedure Call  Abstract  This paper presents the modeling and formal verification of some communication protocols for Remote Procedure Call (RPC). These protocols include Request (R) Protocol, Request Reply (RR) Protocol and Request-Reply-Acknowledgement (RRA) Protocol. We have modeled the above-mentioned protocols in Symbolic Model Verifier (SMV), a formal verification tool. In modeling of each protocol, each of the two agents (Client and Server) is modeled as a finite state machine. The common channel between these agents is modeled as a bounded queue of message. Some important features of modeled protocols are then formal verified using the SMV tools.  Key words:   Formal Verification, Symbolic Model Verifier, Remote Procedure Call, Request protocol, Request Reply protocol, Request Reply Acknowledgement protocol.  1. Introduction  Finite state concurrent systems arise naturally in several areas of computer science such as in the design of digital circuits, communication protocols, distributed systems etc. Logical errors found late in the design phase of these systems are an extremely important problem for the circuit designers, protocol designer and the programmers.  Simulation and testing [1] are some of the traditional approaches for verifying the finite state systems. Simulation and testing both involve making experiments before deploying the system in the field. While simulation is performed on an abstraction or a model of the system, testing is performed on the actual product. In the case of circuits and protocols, simulation is performed on the design of the circuit and on that of protocols, whereas testing is performed on the systems themselves. In both cases, these methods typically inject signals at certain points in the system and observe the resulting signals at other points. For software, simulation and testing usually involve providing certain inputs and observing the corresponding outputs. Besides, checking all of the possible interactions and finding potential pitfalls using simulation and testing techniques is not always possible. Formal verification [2], an appealing alternative to simulation and testing, conducts an exhaustive exploration of all possible behaviors of the system. Thus, when a design is marked correct by a formal verification method, it implies that all behaviors have been explored and the question of adequate coverage or a missed behavior becomes irrelevant. There are some robust tools for formal verification such as SMV, SPIN, COSPAN, VIS, SMART etc [2]. This paper presents the modeling and formal verification of some communication protocols for RPC. We have used SMV as the verification tool.  2. Related Works  People have researched formal verification of computer hardware and software for decades. Formal specification of bus protocols (for example, PCI local bus) have been studied widely and extensively [3,4,5,6]. The work in [6,7] promotes a specification style in which the bus protocol is described through an observer, which raises errors signals on the violation of the protocol. A formal verification of the Advanced Micro-controller Bus Architecture (AMBA) protocol from ARM has recently been studied [8]. This protocol has been formally verified using SMV. The Alternating Bit Protocol (ABP) has been verified using formal verification technique [9]. Formal Verification has been also applied to verify the Embedded HW-SW Shared Memory Systems [10]. The bus protocol of the Intel Intenium processor has been formally verified by the SMV model checker [7]. Besides, so many protocols and finite state concurrent systems are being verified using SMV model checker.   3. Formal Verification  Formal verification [2] is used to check if a system holds a property or not. The promise of verification is proving in the sense of mathematical proof, in contrast to conventional simulation and test, which can tell us only that nothing went wrong on the specific case we tried. Obviously, exhaustively trying every possible execution of a system is a valid proof. The formal verification can be viewed as giving the effect of this exhaustive simulation.  Nilimesh Halder, A.B.M Tariqul Islam, Ju Bin Song     Telecomm. Lab, Dept. of Electronic & Radio Eng.,    Kyung Hee University, Korea   
IJCSNS International Journal of Computer Science and Network Security, VOL.7 No.7, July 2007    64 3.1 Model Checking  To understand the term model, we need to be familiar with transition system and Kripke Structure. A transition system is a structure TS = (S, S0, R) where, S is a finite set of states; S0⊆ S is the set of initial states and R ⊆ S×S is a transition relation which must be total i.e. for every s in S there exists s1 in S such that (s, s1) is in R. On the other hand, M= (S, S0, R, AP, L) is a Kripke Structure; where (S, S0, R) is a transition system. AP is a finite set of atomic propositions (each proposition corresponds to a variable in the model) and L is a labeling function. It labels each state with a set of atomic propositions that are true in that state. The atomic propositions and L together convert a transitions system into a model.  The foremost step to verify a system is to specify the properties that the system should hold. For example, we may want to show that some concurrent program never deadlocks. Once we know which properties are important, the second step is to construct a formal model for that system. The model should capture those properties that must be considered for the establishment of correctness. Each formula representing a property is either true or false in a given state of Kripke Structure. Its truth is evaluated from the truth of its sub formula in a recursive fashion, until one reaches atomic propositions that are either true or false in a given states. A formula is satisfied by a system if it is true for all the initial states of the system. Mathematically, say, a Kripke Structure K= (S, S0, R, AP, L) and a formula φ (specification of the property) are given. We have to determine if K | = φ holds (K is a model of φ) or not. K | = φ holds iff K, s | = φ for every s∈S0. If the property does not hold, the model checker generally produces a counter example that is an execution path that cannot satisfy that formula.  3.2 Symbolic Model Verifier (SMV)  SMV [11] is a formal verification tool that is used to automatically verify the properties of interacting finite state machines. In SMV, properties are specified in a notation called Computation Tree Logic (CTL), one kind of temporal logic. The input language of SMV allows us to describe each of the agents of a system as a module. In particular, the initial states and the transition relation of each of the modules can be specified. SMV constructs a global state transition graph of the entire system from the description of each module. The transition relation and sets of states are viewed as boolean functions. These are represented efficiently by a compact data structure called Binary Decision Diagram (BDD) [12] which involves structure sharing.  3.2.1 Computation Tree Logic (CTL) Formula  Atomic propositions, standard boolean connectives of prepositional logic (e.g., AND, OR, NOT) and temporal operators all together are used to build the CTL formula [13]. Each temporal operator is composed of two parts: a path quantifier (universal (A) or existential (E)) followed by a temporal modality (F, G, X, U) and are interpreted relative to an implicit “current state”. There are generally many execution paths (the sequences) of the state transitions of the system starting at the current state. The path quantifier indicates whether the modality defines a property that needs to hold on some paths (denoted by existential path quantifier E) or on all paths (denoted by universal path quantifier A). The temporal modalities describe the ordering of events in time along an execution path and have the following meaning. (i) F Ø (“reads ‘Ø’ holds sometime in the future”) is true in a path if there exists a state in that path where formula ‘Ø’ is true. (ii) G Ø (“reads ‘Ø’ holds globally”) is true in a path if ‘Ø’ is true at each and every state in that path. (iii) X Ø (“reads ‘Ø’ holds in the next state”) is true in a path if ‘Ø’ is true in the state reached immediately after the current state in the path. (iv) Ø U φ (“reads ‘Ø’ holds until ‘φ’ holds”) is true in a path if ‘φ’ is true in some state in that path, and ‘Ø’ holds in all preceding states. 3.2.2 Specification of Properties in CTL  CTL formulas are sometime problematical to interpret. For this, a designer may fail to understand what property has been actually verified. Here, we want to add some common constructs of CTL formula. (i) AG (Req → AF Ack): it is always the case that if the signal Req is true, then eventually Ack will also be true. (ii) AG (AF DeviceEnabled): DeviceEnabled holds infinitely often on every computation path. (iii) AG (EF Restart): from any state, it is possible to get to the Restart state. (iv) AG (Send → A (Send U Recv)): if Send holds, then eventually Recv is true, and until that time, Send remains true. (v) EF (~Ready ∧ Started): It is possible to get to a state where holds started, but ready does not hold. (vi) AG (in → AX AX AX out): Whenever in goes high, out will go high within three clock cycles. (vii) AG (~storage_coke → AX storage_coke): If the coke storage of a vending machine becomes empty, it gets recharged immediately. 3.2.3 Fairness Constraints  In verifying concurrent systems, we are occasionally interested only in correctness along fair execution. It is often necessary to introduce some notion of fairness. For example, if there are two processes trying to use a shared resource using an arbiter, we may wish to consider only those executions in which the arbiter does not ignore one 
IJCSNS International Journal of Computer Science and Network Security, VOL.7 No. 7, July 2007   65 of its request inputs from either of the processors forever. Alternatively, we may want to consider communication protocols that no message is ever continuously transmitted but never received. A fairness constraint can be an arbitrary set of states, usually described by the formula of the logic. If fairness constraints are interpreted as a set of states, then a fair path must contain an element of each constraint infinitely often. If fairness constraints are interpreted as CTL formulas, then a path is fair if each constraint is true infinitely often along the path. The path quantifiers in the logic are then restricted to fair path. A fairness condition P restricts the system to only those paths where P is asserted infinitely often. Basically the fairness constraints are used to rule out undesired executions.  4. Remote Procedure Call (RPC)   RPC is a special case of the general message-passing model of Inter Process Communication (IPC). The primary motivations for developing RPC facility is to provide the programmers with a familiar mechanism for building distributed applications. The RPC mechanism is an extension of the local procedure call in the sense that it enables a call to be made to a procedure that does not reside in the address space of the calling process [14]. The remote procedure may be on the same computer as the calling process or on a different computer.  In case of RPC, since the caller and the callee processes have disjoint address space, the remote procedure has no access to data and variables of the caller’s environment. Therefore, the RPC facility uses a message-passing scheme for information exchange between the caller and the callee processes. Fig. 1 shows a typical model of a remote procedure call. The client sends a request message to the server and waits for a reply message. After receiving the request message, the server starts execute the procedure and sends a reply message to the client and wait for next request message. When client receives the reply message, it resumes execution.  Based on the needs of different systems, several RPC communication protocols already exist [15]. These are: (i) The Request Protocol (R Protocol) (ii) The Request /Reply Protocol (RR Protocol) and (iii) The Request /Reply/ Acknowledge-Reply Protocol (RRA Protocol).  4.1 The Request Protocol  This protocol is also known as the R (request) protocol. It is used in which the called procedure has nothing to return as the result of procedure execution and the client requires no confirmation that the procedure has been executed. The  client normally precedes execution immediately after the sending the request message, as there is no need to wait for a reply message. The protocol provides call semantics and requires no retransmission of request messages. Fig. 2 shows the message communication of R Protocol. The client sends request message to the server and the server executes the procedure after receiving the request.  
                       4.2 The Request/Reply Protocol  This protocol is also known as the RR (request-reply) protocol. The protocol is based on the idea of using implicit acknowledgement to eliminate explicit acknowledgement messages. (i) A server’s reply message is regulated as an acknowledgement of the client’s request message. (ii) A subsequent call packet from a client is regarded as an acknowledgement of the server’s reply message of the previous call made by that client. To take care of lost message, timeout based retransmission technique is normally used along with RR protocol. A client retransmits request message if it does not receive the reply message within the predetermined timeout period. 
Servers can support exactly-once call semantics by keeping records of the replies in a reply cache that enables them to filter out duplicate request message and to retransmit reply messages without the need to reprocess a request. Fig. 3 shows the message communication of RR Protocol. The client sends a request message to the server and waits for a reply message. After receiving the request message, server executes the procedure and also sends a reply message to the client that serves as an acknowledgement for the previous request message. When client receives the acknowledgement from server, it sends next request message that serves as an acknowledgement of previous RPC.  4.3 The Request/Reply/Acknowledge-Reply Protocol  This protocol is also known as RRA (Request/Reply/Acknowledge-Reply) protocol. The RRA   Call and  wait for  reply  Receive and start  procedure execution  Caller (Client process) Caller (Server process) Resume executionSend reply  and wait for next request  message  Request   Message Reply   Message  procedure execution  Client Server procedure  execution Request   Message Request  Message First RPC Next RPC  Fig. 1  A typical model of Remote   Procedure CallFig. 2  The Request Protocol
1234567890ABCDEFGHIJKLMNabcdefghijklmn!@#$%^&&*()_+.一三五七九贰肆陆扒拾，。青玉案元夕东风夜放花千树更吹落星如雨宝马雕车香满路凤箫声动玉壶光转一夜鱼龙舞蛾儿雪柳黄金缕笑语盈盈暗香去众里寻他千百度暮然回首那人却在灯火阑珊处

您的评论      


240发布评论
用户评价
暂无评论
上传文档
 相关文档推荐
 Remote Procedure Call编...

 9页 
 Remote Procedure Call

 1页 
 Remote Procedure Call ...

 30页 
 Remote_procedure_call_...

 64页 
喜欢此文档的还喜欢
 rfc1831.RPC Remote Pro...

 18页 
 rfc1057.RPC Remote Pro...
*
*
*
@author: Mohit Nainwal
*
*
*
 25页 
 A Survey of Remote Pro...

 24页 
 rfc3529.Using Extensib...

 15页 
 Designing an agent syn...

暂无评价 27页 
猜你喜欢
©2019 Baidu | 由 百度云 提供计算服务 | 使用百度前必读 | 文库协议 | 广告服务 | 企业文库 | 网站地图

 
选择内容扫一扫
立即发送到手机×
VIP享无限制发送特权
以下结果由提供：×
百度翻译
百科词条：×
百度百科
分享到：QQ空间新浪微博微信
文档可以转存到百度网盘啦！
/9
0下载券立即下载 
加入VIP
获取更多特权
复制 | 发送到手机 | 搜索 | 翻译

文字已复制